This file describes the Items that are next on the TODO list. **This list is NOT EXHAUSTIVE!**

1. ~~add instance-of and cast operations~~
2. implement module dependencies and access checks
   1. ~~upgrade the compilers CLI interface to a configuration via a proper config format. NOT YAML! Maybe TOML, maybe PKL. Should have schema~~
   2. ~~implement dependencies between input modules/source sets~~
       * ~~stdlib depends on platform module provided by backend~~
       * ~~modules only have access to things in other modules that they explicitly depend on~~
3. extend OO model
   1. ~~implement `mixin`s~~
   2. refactor diagnosis
      1. ~~use Diagnosis instead of ˋCollection of Reportingˋ~~
      2. ~~refactor purity checks to visitor pattern~~
      3. ~~rename Reporting to Finding? A diagnosis lists findings; the compiler diagnoses the input code~~
      4. ~~handle errors in generated code: hide them from the user as long as there are errors in user-provided
         code. Only stop compilation with blame in the compiler if the ONLY problems that are found are in
         code generated by the compiler. Because only then is it clear that the compiler fucked up instead of just
         basing generated code on faulty user input.~~
   3. ~~add accessor-based member variables to interfaces~~
   4. ~~review the vtable approach: does looking for a prefix suffice to keep them small?~~
       * idea 1: put 1s into the bitwise hashes at different, non-harmonic frequencies to generate hard-to-clash patterns
           * maybe adding phase-shift helps even more
           * e.g. '10101010101010...', '100100100100100100', '1000100010001000'
       * if that isn't enough, it could make sense to include both a left- and a right shift, so any unique
         sequence from the hashes can be chosen, not just prefixes.
       * TEST, TEST, TEST. Unit test the shit out of the algorithm. More to proof the concept, less to
         test the implementation.
   5. ~~intersection type: `TypeA & TypeB & TypeC`~~
   6. ~~solve the wrapper mutability problem. Wrappers *must* be parametric on mutability, but since parametric types
      already carry a mutability, wrapper mutability can likely piggy-back onto that. It needs union types or multiple
      type parameter bounds.~~
4. general iterable types
   * implement generic supertypes - yey, another logic monstrosity
   * Like Java Iterable<T>, D ranges, ... ?
   * for each over iterable
5. arrays slices; goal/target situation
   * there are array-base-objects, identical to what an Array<T> is before
   * emerge source can never reference these base objects directly, only ever slices of that
   * when emerge source says "Array<T>", this is actually a fat pointer consisting of
     * a pointer to the base array object that holds reference count, vtable, the length of the memory chunk
       and the actual array data
     * a pointer to the first element in the slice
     * the length of the slice
   * so when you have a variable/parameter of type `Array<T>`, it can be a full array, but could also just be
     a sub-slice of one
   * `Array.new<T>(UWord, T)` creates a base array object and then returns a slice covering the entire array
   * slicing functions, e.g. `someArray[1..5]`
   * how to deal with `exclusive` mutability? idea: Array.new is the only way to get hold of an `exclusive`
     slice. Slicing operations always capture the old slice, stopping the exclusive lifetime and settling the
     sub-slice to either `mut` or `const`
   * apply to standard library, especially IO functions
6. isolate thread-unsafe global state
   * standard IO. E.g. the `main` function could receive an optional parameter that carries with it fields
     that hold stdin, stdout, stderr. At a later point, these can be sent to other workers/threads. That would
     require a builtin that asserts a certain stack-variable is exclusive, but that doesn't seem impossible to provide.
   * anything else to take care of?
7. additional language constructs
   1. switch/when statement
   2. union types: `TypeA | TypeB | TypeC`
      * support exhaustiveness check on switch/when statements
   3. inferable types? Be able to mention `_` anywhere where inference is supported and have that part of the
      type be filled in by the compiler. Useful for the foreach syntax sugar: range: mut InputRange<_> = iterable.asRange()
   4. bug: the following code does not count as definitely terminating:
      ```
      try { return fallibleCall() } catch e { throw rewrap(e) }
      ```
8. Stdlib basics
   * some good standard collections
   * ArrayList, LinkedList, (De)Queue, Stack, ...
     * hashCodes: Java-style is overkill, have an explicit Hashable interface
   * Map
   * string templates
     * interpolation like in Kotlin instead of concatenation like in Java or D
     * make that work with the Printable interface. So e.g. a template "a ${x} b ${y} c" desugars to an
       memory-buffered printstream, with calls to put of "a ", x.printTo(...), " b ", y.printTo(...), " c"
   * I/O facilities. These should be blocking-style for now. It's the simplest to implement. Plus: if emerge ever
     adds async task orchestration, it will be either full-blown coroutines (all code is a coroutine, like in go)
     or futures. Futures is a major rewrite of emerge code anyhow, but changing blocking IO to coroutine IO is transparent
     to the emerge code.
9. ALPHA TESTABLE MILESTONE; At this point, the language should be powerful enough to tackle advent of code challenges.
   Todo: actually try and solve some!
10. integration tests!! Include emerge source code in this repository that tests the runtime and correct compilation.
    The unit tests in the frontend test the negative cases; these should test the positive ones. E.g. that 2+3=5,
    refcounting, control flow + exceptions, ...
    * ideally, valgrind can be used as a library in the testing framework to check every single test-case
      for memory leaks.
11. documentation and presentation
    * from a user perspective. Github pages?
      * language syntax and semantics, maybe a good tutorial
      * design decisions, philosophy and reasoning
    * from a maintainer perspective
      * compiler architecture
      * llvm patterns
      * debugging techniques
    * add fix suggestions to diagnostics; this should also make them much more comprehensible
12. user tooling
    * language server and VSCode plugin
    * think about an assistant, e.g. taking care of these tasks
      * manage installed toolchain versions, at least on linux
      * automate grunt work like
        * setting up a new project including bazel build
        * adding modules or dependencies to existing projects
        * if emerge ecosystem/libraries are already a thing: manage dependencies
13. runtime checks for generic parameters
    * does that need to be enabled by the programmer? Could be e.g. `class Array<reflect T>` if necessary
    * how to represent at runtime?
    * implement checked casts
      1. implement wildcard generic parameter to address unchecked generics, where the wildcard is always
         treated as if it was the bound of the parameter. E.g. given `class Pair<reflect out A, reflect out B>`,
         `x as Pair<String, *>` is treated like `Pair<String, Any?>`
      2. implement type data structures equivalent to what the compiler has
      3. implement isSubtypeOf checks for these data structures, like the compiler does
         * how to keep these in sync?? Tests, tests, tests!
      4. implement that isSubtypeOf check into the `is` and `as` operators. Afterwards, an `Array<String>`
         must not possibly be referenced as an `Array<S8>`
14. Function types
    1. add function types to the grammar and type system.
       * do it like Kotlin where function types are syntax sugar for `FunctionN<...>`?
         (`(A, B) -> C = emerge.core.Function2<A, B, C>`)
    2. deal with the higher-order function purity problem: do functions need to be generic on purity?
       * probably not. The compiler needs to implement parameteric side effects internally, but in the emerge language
         we can probably void that complexity. The trick is: we have the language concept of `borrow` already. If a
         function borrows a value of a function type, it HAS to invoke that function zero-or-more times during its own
         execution, and cannot possibly invoke it later. So the side-effect only needs to be tracked during the invocation
         of the higher-order function. Thus, we get a simple heuristic: 
         if a function receives a parameter that is of a function type, and that parameter is borrowed: add a hidden
         side-effect parameter to the function that is also applied to the parameter;
         e.g. `fn foo(borrow a: () -> Unit)` gets an internal representation of `E fun foo<effect E>(borrow a: E () -> Unit)`
    3. implement references to top-level functions
    4. implement `foo()` where `foo` is an expression of a function type
       * !! edge case: `objectRef.foo()` where `foo` is a property of a function type
    5. implement lambda functions
       * syntax idea
         * single expression lambda: `fn (a, b) -> a + b`
         * code-chunk lambda: `fn (a, b) -> { ... ; ... ; return x }`
         * what about implicit `it` for single-parameter function types? `fn -> it.foo` and `fn { it.foo }`?
    6. implement last-argument lambdas like in Kotlin?
       * `fn a(p1: S32, p2: () -> Unit)` and invoke like `a(3) { /* lambda body */ }`
15. functional-style collection operations (possible because the higher-order function purity problem is solved)
    1. start simple with forEach
    2. go on with filter, map, fold, ...
    3. more tricky: make sure the code emitted by LLVM doesn't actually do all the allocation. A chain of maps and filters
       should be compiled down to a single loop.
16. import aliases: `import emerge.platform.print as platformPrint`, `import emerge.std.HashMap as DefaultMutableMap`
17. optimize reference counting; see [](refcounting optimizations.md)
    * for this, the logic to determine where reference counts are needed must move from the LLVM backend to
      the frontend; the frontend has the tools to deal with the complexity, the backend doesn't. Especially
      temporary values are BAD offenders
18. typealiases
19. smart casts
20. fix loophole in the typesystem: the `exclusive` modifier becomes incorrect in this code:
    ```
    class Foo {}
    arr = Array.new::<exclusive Foo>(20, Foo()) // compiler doesn't complain, but should
    v: exclusive Foo = arr[0] // compiler doesn't complain here, either
    ```
21. optional parameters
    * parameter with default value is optional
    * affects overload validation and resolution
    * default value should be evaluated on the caller side because it allows to keep the
      ABI calling conventions
      * as a consequence, only the initial declaration of a function can declare default values,
        overrides cannot
22. named arguments
    * allow to change the order of arguments? Its important to keep the evaluation order on the
      calling side to match the order of the arguments as passed, not as declared
23. threading
    The whole shtick of the explicit-mutability types is to simplify multithreading. Avoiding the
    complexity of having a `shared` mutability like D allows to infer some properties necessary for
    multithreading:
    * mutable global state as in D: it is not shared across threads. Each thread has its own copy,
      starting a new thread re-initializes the mutable global state as defined in the source (as opposed
      to copying it from the parent thread).
      * maybe even ditch global state all together? Is that feasible / sensible?
    * "Dont communicate by sharing state, share state by communicating": there are no shared objects between
      threads. We'll have an actor model like Go or Erlang, where each thread as a (typed) inbox and receives
      messages from other threads on which it can act.
    * When sending a value to another thread, that thread gets a _deep copy_ of that value. This avoids having
      to do the runtime reference counting with atomics. It is only allowed to send `immutable` references
      to other threads. This has two crucial benefits:
      * it makes the necessary copy operation opaque / hide-able
      * it prevents the possibility of sending resource pointers (like file handles) to other threads (these
        are always mutable), avoiding the un-solvable problem of "how do i make a copy of a resource pointer?"
      * It can be optimized in the guts of the channel impl: if a value is to be sent to another thread
        and its reference count is `1`, then no copying is necessary.
    * there should be ready-made open-source Erlang-like channel implementations in C that the stdlib can
      use, making it feasible to implement
    * This complicates lambda literals that capture values by reference. Is it possible to copy these?
      Or should lambda literals that capture references have `read` mutability to prevent them from being
      sent across threads? This is important to get a decent WorkerThread/ForkJoinPool API.
    * On the matter of ForkJoin/WorkerThread: this would necessitate a Futures API:
      ```
      val futureVal: Future<S32> = forkJoinPool.submit({ doExpensiveComputation() })
      ```
      Which brings the important question to the table: Push-Based or Pull-Based futures?
24. various optimizations collected over time
    * static dispatch for mixed-in functions when the concrete type of the mixed-in object is known
      at compile time

-----

## Future features

### Refactoring bucketlist

* denote all identifiers quoted from input source that appear in diagnostics. Is already done
  sporadically -> do systematically
* give every diagnostic type a code (like typescript does)

### Stateless Singletons

Emerge can't have Kotlins `object` singletons because that suggest a single identity per program execution,
but due to how all other state works, it would be an identity per thread. That complicates sending these
singletons across threads even more complicated. The possible solution: atoms. Like in functional and logic programming,
atoms are stateless identities. Because they're stateless they can retain their identity across all threads, just
like string literals/constants. They could even implement interfaces. Atoms can come in handy together
with algebraic data types to form Java-Like enums:

    atom A {}
    atom B {}
    atom C {}
    typealias Enum = A | B | C

Implementing interfaces is handy for modelling state external to the program:
_!! how to prevent race conditions in the external resource when multiple emerge threads/actors are mutating
the same atom?_

    atom StandardOut : PrintStream {
        override fn put(self: mut _, string: String) {
            // ...
        }
    }

### Feed LLVM with all info available

Without targeting specific optimizations, it probably still helps performance to feed LLVM all information that is
available. These are possible (not exhaustive):

* `zeroext` / `signext` on numeric and boolean return values
* `dereferenceable(<n>)/dereferenceable_or_null(<n>)`
  * parameters
  * return values
  * stack read results
  * heap read results (object member access)
* `nofree` for borrowed parameters
* `noundef` - for everything??
* `readnone` - for unused parameters
* `readonly` - for readonly/constant parameters
* `nounwind` on functions, as exceptions use the regular return path in LLVM
* `inbounds` on most getelementptr instructions. the current DSL already goes.to great lengths to ensure that, so it's probably safe to assume the constraints for `inbounds` are never violated
* `nosync` on all/most emerge functions. the language is single threaded right now. once multi threading comes in the form of executors and channels, the channel API must somehow be made to not have the `nosync` attribute
* weights for branches
  * mark the exception path on function invocations as unlikely
  * mark the exception branch on fallible math as unlikely
  * loop header conditions should be heavily likely - after all, loops are supposed to be run often

### Forced Type Mutability

For some types, certain mutabilities don't make sense. E.g. a `const Weak` doesn't make any sense 
as the weak reference can turn `null` at any point.
For primitive number types (and for strings, too, probably), mutability doesn't make sense, so they
can always be `const`.

-> Allow the programmer to express this in the type definition

Could e.g. be

```
const class S8 { }

read class Weak<T> { }
```

For `Weak`, this is a bit tricky. `read` is the middle ground between `const` and `mut`, so declaring a
class as `read` doesn't say to which side it should gravitate. It might need to be `read|mut class Weak<T>`

### API comparison tool

A tool that can compare the source-code API of two modules. This can fulfill two use cases:

#### Help with library versioning

When releasing a new version of a library that is of the same major version as the previous release, automated tooling can
assist in assuring backwards compatibility by ensuring the new version doesn't break any source-level APIs. This could work
as a tool that can be given two versions of the same module and would output:

```
class ToolOutput {
  breakingChanges: List<ApiChange> = init
}

interface ApiChange {
	location: Span
	message: String
}
// and then e.g.
class TypeRemoved : ApiChange {
	name: CanonicalElementName
	override message = "Type ${name.simpleName} is no longer available."
}

// given
class Span {
	file: String = init
	fromLine: S32 = init
	fromColumn: S32 = init
	toLine: S32 = init
	toColumn: S32 = init
}
```

So, to the user, it could be shown like this:

```
[ERROR] Breaking change in minor version release: Type com.foo.bar.Frobnicator is no longer available.

in previous/src/Frobnicator.em:
   9 |
  10 | class Frobnicator {
     |       ^^^^^^^^^^^
  11 |
```

#### Assuring portability of emerge code

The `emerge.platform` module already has it's API defined in [backend-api](backend-api/src/main/emerge/noop-backend-platform).
To assure that code outside of `emerge.platform` remains portable, the build process of the compiler should assure
that all implementations of `emerge.platform` expose the **exact same** API as the abstract module. This makes sure that
all platforms implement the complete API, **plus** it makes it impossible for some emerge code to be tied to a specific
platform because the platform is not allowed to expose APIs exclusive to itself.

### Invariants

Steal from D

Classes and traits can define invariants. Those are checked
* after construction
* at the end of each method that can modify the receiver

```
class Foo {
    var x: S32 = init
    
    invariant {
        assert(x.rem(4) == 0)
    }
    
    fn addToX(self: mut _, valueToAdd: S32) {
        prevX = self.x
        set self.x = 3 // this does not trigger the invariant
        set self.x = prevX + valueToAdd
        // here, the invariant gets checked
    }
}

a = Foo(3) // panics due to the violated invariant
b = Foo(4) // okay
b.addToX(4) // this works; the temporary violation of the invariant is ignored
b.addToX(3) // this panics due to the violated invariant
```

#### Contract programming

Also steal from D?

### Emergent properties
Statements about the state of an object, e.g. isAbsolute on Path:
```
class Path {
    val segments: Array<String>
    property Absolute(self) = self.segments[0] != ""
}
```
It is derived from fields of an object. Because of mutable objects, it can only read fields that
are constant across the lifetime of the object. These could be marked with `final`, so e.g. interfaces
can declare properties, too, regardless of how the values are implemented. On all impls of final fields,
the compiler then has to verify that the field is not mutable, assigned at construction time or derived only
from other final fields.
Alternatively, the property could declare `immutable` on the `self` argument, making the property only available
on `immutable` references to that type, e.g.:

```
class List {
    property Empty(immutable self) = size == 0
}
```

You could then reference these properties in APIs, further strengthening the contract:
```
fun reduce(readonly self: List<out T> + !Empty, reductor: (T, T) -> T) -> T {
```

And callers would then first have to check for that property, smart-casts enabling sane UX:
```
val myList: List<S32>
val result: S32 = if (myList !is Empty) myList.reduce(S32::plus) else 0
```

Properties could also subtype each other, meaning that one property implies the other:
```
class List {
    property Empty(immutable self) = size == 0
    property Singleton(immutable self) : !Empty = size == 1
}
```

#### What's the purpose?
This could enable some level of dynamic typing: properties are simple types, and can be present
on a value based on its state, not based on the implementation. Simplifies inheriting multiple
interfaces in the presence of multiple implementations.

### CTFE

How complicated? Running stuff is probably easy, deducting *what* to run is probably hard.
Also, the CTFE needs a strict timeout (maybe user-configurable?) so when it runs an infinite loop,
it eventually continues.

[1]: https://openjdk.org/jeps/447
